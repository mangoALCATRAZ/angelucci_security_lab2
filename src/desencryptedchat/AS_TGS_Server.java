/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package desencryptedchat;

import java.io.IOException;
import java.util.*;
import java.net.*;
import java.nio.charset.Charset;
import java.sql.Timestamp;

import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
import java.util.logging.Logger;


/**
 *
 * @author woah dude
 */
public class AS_TGS_Server {
    public static Scanner scan = new Scanner(System.in);
    
    private static String K_c = "";
    private static String K_c_tgs = "";
    
    private static String K_c_tgs_for_tgs = "";
    private static String K_tgs = "";
    private static String K_v = "";
    
    private static String ID_tgs = "";
    private static String ID_c = "";
    private static String ID_v = "";
    
    private static String ticket_tgs = "";
    
    private static String ticket_tgs_for_tgs_encrypted = "";
    private static String ticket_tgs_for_tgs = "";
    private static String ID_c_from_ticket_tgs = "";
    private static String ID_tgs_from_ticket_tgs = "";
    private static String ID_c_from_authenticator_c = "";
    
    
    
    
    
    private static String authenticator_c_encrypted = "";
    private static String authenticator_c = "";
    
    private static String ts1_string = "";
    private static long ts1_long;
    private static String ts2_string = "";
    private static long ts2_long;
    
    private static String ts2_string_from_ticket_tgs = "";
    private static long ts2_long_from_ticket_tgs;
    
    
    
    private static int lifetime_2 = 60000; // in milliseconds
    private static int lifetime_2_from_ticket_tgs;
    
    private static String AD_c = "";
    
    private static String AD_c_from_ticket_tgs = "";
    private static String AD_c_from_authenticator_c = "";
    
    
    
    private static String K_c_v = ""; // session key between c and v generated by TGS
    private static String ts4_string = "";
    private static long ts4_long;
    private static int lifetime_4 = 86400000;
    
    private String ticket_v_unencrypted = "";
    private static String ticket_v = "";
    
    private static int state = 1;
    
    private static boolean done = false;
    
    public static void main(String[] args) throws Exception{
        System.out.println("\nAS/TGS Server");
        
        System.out.println("\n\nPlease enter the user's password:");
        String k_c_semiKey = scan.nextLine();
        K_c = ChatHelper.keyConverter(k_c_semiKey);
        
        System.out.println("\nPlease enter the K_tgs key:");
        String k_tgs_semiKey = scan.nextLine();
        K_tgs = ChatHelper.keyConverter(k_tgs_semiKey);
        
        System.out.println("\nPlease enter the K_v key:");
        String k_v_semiKey = scan.nextLine();
        K_v = ChatHelper.keyConverter(k_v_semiKey);
        
        Socket sock = null;
        String input;
        int port = 5000;
        
        while(done == false){
            
            switch(state){
                case 1:
                    //Step 2: AS -> C
                    Socket cSock = null;
                    while(cSock == null){
                        cSock = NetworkMethods.hostMethod(port);
                    }
                    System.out.println("\nAS connected to C_Client!");
                    try{
                        authentication_server(cSock);
                        cSock.close();
                        break;
                    }
                    catch(Exception e){
                        System.out.println(e.getMessage());
                        done = true;
                        break;
                    } catch (Throwable ex) {
                        Logger.getLogger(AS_TGS_Server.class.getName()).log(Level.SEVERE, null, ex);
                        System.out.println(ex.getMessage());
                        break;
                    }
                case 2:
                    //Step 4: TGS -> C
                    
                    Socket cSock2 = null;
                    while(cSock2 == null){
                        cSock2 = NetworkMethods.hostMethod(port);
                    }
                    System.out.println("\nTGS connected to C_Client");
                    try{
                        ticket_granting_server(cSock2);
                        done = true;
                    }
                    catch(Exception e){
                        System.out.println(e.getMessage());
                        done = true;
                        break;
                    }  catch (Throwable ex) {
                           Logger.getLogger(AS_TGS_Server.class.getName()).log(Level.SEVERE, null, ex);
                           done = true;
                           break;
                    }
                    done = true; // placeholder
                    break;
                default:
                    break;
            }
        }
        
    }
    
    public static void ticket_granting_server(Socket cSock) throws IOException, InterruptedException, Throwable{
        listenerThread listener = new listenerThread(cSock, K_c_tgs);
        listener.setDecryptFlag(false);
        listener.start();
        
        SenderClass sender = new SenderClass(cSock);
        
        while(listener.shareGet() == null && done == false){
            TimeUnit.SECONDS.sleep(1);
            
        }
        String response_from_c = listener.shareGet();
        if(checkNoOfDelims(response_from_c, 2) == true){
            System.out.println("\n\nReceived:");
            StringTokenizer st = new StringTokenizer(response_from_c, ";");
            for(int i = 0; st.hasMoreTokens(); i++){
                switch(i){
                    case 0:
                        ID_v = st.nextToken();
                        System.out.println("ID_V:" + ID_v);
                        break;
                    case 1:
                        ticket_tgs_for_tgs_encrypted = st.nextToken();
                        System.out.println("Encrypted ticket_tgs:" + ticket_tgs);
                        break;
                    case 2:
                        authenticator_c_encrypted = st.nextToken();
                        System.out.println("Encrypted authenticator_c:" + authenticator_c_encrypted);
                        break;
                }
            }
            
            // decrypt received ticket_tgs
            KeyGenerator kg_ticket_tgs = new KeyGenerator(K_tgs);
            String [] ReversedRoundKeyArraykg_ticket_tgs = kg_ticket_tgs.keyGenerator(kg_ticket_tgs.getKey());
            ReversedRoundKeyArraykg_ticket_tgs = KeyGenerator.roundKeyArrayReversal(ReversedRoundKeyArraykg_ticket_tgs);
            String pt_ticket_tgs_unconverted = EncryptDecrypt.Decrypt(ticket_tgs_for_tgs_encrypted, ReversedRoundKeyArraykg_ticket_tgs);
        
            String pt_ticket_tgs = ChatHelper.binaryStringToText(pt_ticket_tgs_unconverted);
            System.out.println("\n\nTicket Plaintext:" + pt_ticket_tgs);
        
            // parse decrypted ticket_tgs
            if(checkNoOfDelims(pt_ticket_tgs, 5) == true){
                StringTokenizer st_ticket_tgs = new StringTokenizer(pt_ticket_tgs, ";");
                System.out.println("Output from ticket_tgs:");
                for(int i = 0; st_ticket_tgs.hasMoreTokens(); i++){
                    switch(i){
                        case 0:
                            K_c_tgs_for_tgs = st_ticket_tgs.nextToken();
                            System.out.println("Received K_c_tgs:" + K_c_tgs_for_tgs);
                            break;
                        case 1:
                            ID_c_from_ticket_tgs = st_ticket_tgs.nextToken();
                            System.out.println("Received ID_C:" + ID_c_from_ticket_tgs);
                            break;
                        case 2:
                            AD_c_from_ticket_tgs = st_ticket_tgs.nextToken();
                            System.out.println("Recieved AD_c:" + AD_c_from_ticket_tgs);
                            break;
                        case 3:
                            ID_tgs_from_ticket_tgs = st_ticket_tgs.nextToken();
                            System.out.println("Recieved ID_tgs:" + ID_tgs_from_ticket_tgs);
                            break;
                        case 4:
                            ts2_string_from_ticket_tgs = st_ticket_tgs.nextToken();
                            ts2_long_from_ticket_tgs = Long.parseLong(ts2_string_from_ticket_tgs);
                            System.out.println("Recieved Timestamp2:" + ts2_long_from_ticket_tgs);
                            break;
                        case 5:
                            lifetime_2_from_ticket_tgs = Integer.parseInt(st_ticket_tgs.nextToken());
                            System.out.println("Recieved Lifetime_2:" + lifetime_2_from_ticket_tgs);
                            break;
                    }
                }
                // check for ticket validitiy
                Timestamp tsCurrent = new Timestamp(System.currentTimeMillis());
                long tscLong = tsCurrent.getTime();
                
                long life = Long.valueOf(lifetime_2_from_ticket_tgs);
                long diff = tscLong - ts2_long_from_ticket_tgs;
                if(diff < life){
                    // ticket still valid, proceed
                    
                    
                    
                    KeyGenerator kg_authenticator_c = new KeyGenerator(K_c_tgs_for_tgs);
                    String [] ReversedRoundKeyArraykg_authenticator_c = kg_authenticator_c.keyGenerator(kg_authenticator_c.getKey());
                    ReversedRoundKeyArraykg_authenticator_c = KeyGenerator.roundKeyArrayReversal(ReversedRoundKeyArraykg_authenticator_c);
                    String pt_authenticator_c_unconverted = EncryptDecrypt.Decrypt(authenticator_c_encrypted, ReversedRoundKeyArraykg_authenticator_c);
        
                    authenticator_c = ChatHelper.binaryStringToText(pt_authenticator_c_unconverted);

                    //parse decrypted authenticator
                    if(checkNoOfDelims(authenticator_c, 2) == true){
                        System.out.println("\n\nAuthenticator Plaintext:" + authenticator_c);
                        StringTokenizer st_authenticator_c = new StringTokenizer(authenticator_c, ";");
                        System.out.println("Output from received authenticator_c:");
                        for(int i = 0; st_authenticator_c.hasMoreElements(); i++){
                            switch(i){
                                case 0:
                                    ID_c_from_authenticator_c = st_authenticator_c.nextToken();
                                    System.out.println("Received ID_c:" + ID_c_from_authenticator_c);
                                    break;
                                case 1:
                                    AD_c_from_authenticator_c = st_authenticator_c.nextToken();
                                    System.out.println("Received AD_c:" + AD_c_from_authenticator_c);
                                    break;
                                case 2:
                                    System.out.println("Received Timestamp3:" + st_authenticator_c.nextToken());
                            }
                        }
                        
                        //check for authentication match between data from authenticator and data from ticket
                        if(ID_c_from_authenticator_c.equals(ID_c_from_ticket_tgs) && AD_c_from_authenticator_c.equals(AD_c_from_ticket_tgs)){
                            //Authentication succeeded, granting service to V
                            
                            //time to create ticket_v
                            
                            //generate K_c_v session key
                            String ticket_v_proto = "";
                            String rando = randomStringGenerator(10);
                            K_c_v = ChatHelper.keyConverter(rando);
                            
                            Timestamp ts4 = new Timestamp(System.currentTimeMillis());
                            ts4_long = ts4.getTime();
                            ts4_string = String.valueOf(ts4_long);
                            
                            ticket_v_proto = K_c_v + ";" + ID_c_from_ticket_tgs + ";" + AD_c_from_ticket_tgs + ";" + ID_v + ";" + ts4_string + ";" + lifetime_4;
                            System.out.println("\nticket_v Plaintext:" + ticket_v_proto);
                            
                            EncryptDecrypt ed_ticket_v = new EncryptDecrypt(ticket_v_proto, true);
                            KeyGenerator kg_ticket_v = new KeyGenerator(K_v);
                            String[] RoundKeyArray_ticket_v = kg_ticket_v.keyGenerator(K_v);
                            ticket_v = ed_ticket_v.Encrypt(ed_ticket_v.getInitialMessage(), RoundKeyArray_ticket_v);
                            
                            System.out.println("ticket_v ciphertext:" + ticket_v);
                            //time to create message to C
                            String message_to_c_proto = K_c_v + ";" + ID_v + ";" + ts4_string + ";" + ticket_v;
                            
                            sender.sendAThing(K_c_tgs, message_to_c_proto);
                            System.out.println("Done! End of AS/TGS Execution. Shutting down...");
                            listener.end();
                            sender.finalize();
                            scan.close();
                            
                            
                            
                            
                        }
                        
                        else{
                            //authentication failed. Denying Service
                            System.out.println("\n\nUser information mismatch: Access Denied to V.");
                        }
                        
                        
                        
                        
                    }
                    else{
                        System.out.println("\n\nErr: authentiator delims");
                        
                    }
                    
                    
                    
                }
                else{
                    // ticket not valid, send an error back to client
                    sender.sendAThingNoEncrypt("err");
                    done = true;
                }
            }
            else{
                done = true;
                System.out.println("\n\nError: Deccrypted ticket does not have correct # of delims");
            }
        }
        else{
            done = true;
            System.out.println("\n\nError: response from C does not have correct # of delims.");
        }
        
    }
    
    public static void authentication_server(Socket cSock) throws IOException, InterruptedException, Throwable{
        
        SenderClass sender = new SenderClass(cSock);
        
        listenerThread listener = new listenerThread(cSock, K_c);
        listener.start();
        
        listener.setDecryptFlag(false);
        
        // wait for first input
        while(listener.shareGet() == null && done == false){
            TimeUnit.SECONDS.sleep(1);
        }
        
        String response_1 = listener.shareGet();
        if(checkNoOfDelims(response_1, 2) == true){
            // connection established with client successfully!
            // client sent packet of information
            
            System.out.println("\n\nReceived:");
            
            StringTokenizer st = new StringTokenizer(response_1, ";");
            for(int i = 0; st.hasMoreTokens(); i++){
                switch(i){
                    case 0:
                        ID_c = st.nextToken();
                        System.out.println("\nID_C:" + ID_c);
                        break;
                    case 1:
                        ID_tgs = st.nextToken();
                        System.out.println("\nId_tgs:" + ID_tgs);
                        break;
                    case 2:
                        ts1_string = st.nextToken();
                        ts1_long = Long.parseLong(ts1_string);
                        
                        System.out.println("\nTimestamp 1:" + ts1_long);
                        break;
                    default:
                        break;
                }
            }
            
            String ticketProto = "";
            String rando = randomStringGenerator(10);
            K_c_tgs = ChatHelper.keyConverter(rando); // establishes session key between c and tgs
            
            AD_c = "127.0.0.1:5000";
            
            Timestamp ts2 = new Timestamp(System.currentTimeMillis());
            ts2_long = ts2.getTime();
            ts2_string = String.valueOf(ts2_long);
            
            ticketProto = K_c_tgs + ";" + ID_c + ";" + AD_c + ";" + ID_tgs + ";" + ts2_string + ";" + lifetime_2;
            EncryptDecrypt ed_ticket = new EncryptDecrypt(ticketProto, true);
            
            System.out.println("\n\nTicket plaintext:" + ticketProto);
            
            
            KeyGenerator kg = new KeyGenerator(K_tgs);
            String[] RoundKeyArray = kg.keyGenerator(K_tgs);
            
            ticket_tgs = ed_ticket.Encrypt(ed_ticket.getInitialMessage(), RoundKeyArray);
            
            System.out.println("\nTicket ciphertext K_tgs:" + ticket_tgs);
            
            
            // now constructing proto string to send to client
            
            String clientMessageProto = K_c_tgs + ";" + ID_tgs + ";" + ts2_string + ";" + lifetime_2 + ";" + ticket_tgs;
            sender.sendAThing(K_c, clientMessageProto);
            
            System.out.println("\nFull Client Message Plaintext:" + clientMessageProto);
            
            sender.finalize();
            listener.end();
            
            System.out.println("\nSent!");
            
            
            
            state++;
            
        }
        else{
            System.out.println("\n\nError in response from client. Client response does not have correct syntax with ; delimeters");
            done = true;
            
        }
        
        
    }
    
    public static boolean checkNoOfDelims(String inResponse, int num){
        boolean ret = false;
        
        int count = 0;
        
        for(int i = 0; i < inResponse.length(); i++){
            
            if(inResponse.charAt(i) == ';'){
                count++;
            }
        }
        if(count == num){
            ret = true;
        }
        
        return ret;
    }
    
    public static String randomStringGenerator(int size){
        String ret;
        
        byte[] array = new byte[size];
        new Random().nextBytes(array);
        ret = new String(array, Charset.forName("UTF-8"));
        
        return ret;
    }
    

}

